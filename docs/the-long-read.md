# The Long Read

UI development is hard, I don't think anyone would disagree with that. First of all there is state. A lot of state. There is state tighly coupled to the display tree, such as element focus, selected text, open drop-downs and drag-n-drop. This state needs to be preserved when updating the UI. There is shared state between components, such as some selection of entities from your data model. There is state for floating windows, and more transient state for modals. And then there are data, mutable or immutable, and in what cirumstance do these constitute state.

Some state outlives a single session and gets persisted to local storage or the server. Oh, and derrived state which is too expensive to calculate on the fly. State can be incomplete (say hello to undefined errors), inconsistent and out-of-sync. The shape of state evolves due to changing requirements, so you better have versioning and a migration path.

A good UI is very important, and because it is so visible to people (by definition), everyone has an opinion. Every developer knows you can spend a day on some backend feature, and 10 minutes on the button that activates it, and the user feedback will be is about the location of the button on the screen. This perhaps results in the UI being more susceptible to change. The UI is also under more scrutiny leading to less compromise for architectural simplicity. An API or SDK can probably get away with being slightly less elegant if the resulting system is significantly simpler.

If the UI is developed in the browser (isn't it always) there are multiple platforms to deal with: DOM, SVG, the canvas and WebGL. There are multiple browsers, and although the situation has greatly improved, there _are_ still differences. Although HTML appears declarative, is cannot be pure because the resulting DOM nodes can have state, and so sometimes the DOM is, and has to be, manipulated using imperative code. HTML has semantic tags (h1, p, label) but they aren't always used because any element can be style to look and behave like any other element. All of this means the UI is not propertly abstracted and the line between UI and all the other JavaScript is woolly.

UI is usually event driven. Additionally, JavaScript is async (non-blocking). Since the introduction of the `async/await` syntax this is no longer an issue in itself but it should be noted that asynchrony is sticky: an async function will force the calling context to be async as well. To put it another way, normal (sync) functions can be used in an async context, but not the other way around. Now, most web UI frameworks are synchronous in that a component or render function is _not_ in an async context. There is no way, in a non-blocking single-threaded runtime, to turn async into sync.

So how is this generally solved in practice? By creating machinery that divides an async call into two steps and returns some variation of `{ loading: true, data: undefined }` followed by `{ loading: false, data: <data-revision-1> }`. On subsequent calls it might return `{ loading true, data: <data-revision-1> }` followed by `{ loading: false, data: <data-revision-2> }`.

The consequence of this is the introduction of (accidental) state, multiple invocations of a component for a single render cycle and forced caching of the async function's result value. When reading through component code, the developer has to mentally simulate running through the first, second, third and subsequent calls, keeping track of state to understand the behaviour of the component. Multiple invocations by external machinery break the stack trace, complicating error handling, and usually some optional `error` is returned alongside `loading` and `data`.

The result cache needs to be managed, invalidated when input parameters change and destroyed when components go out of scope to avoid memory leaks. Managing cache is complex, even more so when it is coupled to a UI, and puts pressure on the garbage collector.

Finally, UIs are hierarchical: the location of components in the display tree depends on the location on the screen, whether flow or absolute positioning is used, and the position in the display stack (z-index). What tends to happen is that other aspects such as the data models, control logic, and the passing of properties and events are coupled to, and takes the shape of, that hierarchy. This is a coupling you can do without, makes changing the visual layout a heavy job, because all the coupled code has to move with it, and makes it less reusable in other contexts.
